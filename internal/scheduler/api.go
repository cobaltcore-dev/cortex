// Copyright 2025 SAP SE
// SPDX-License-Identifier: Apache-2.0

package scheduler

import (
	"encoding/json"
	"net/http"

	"github.com/cobaltcore-dev/cortex/internal/logging"
)

var (
	// NovaExternalSchedulerURL is the URL of the Nova external scheduler
	APINovaExternalSchedulerURL = "/scheduler/nova/external"
)

// Spec object from the Nova scheduler pipeline.
// See: https://github.com/sapcc/nova/blob/stable/xena-m3/nova/objects/request_spec.py
type APINovaExternalSchedulerRequestSpec struct {
	ProjectID  string `json:"project_id"`
	NInstances int    `json:"num_instances"`
}

// Host object from the Nova scheduler pipeline.
// See: https://github.com/sapcc/nova/blob/stable/xena-m3/nova/scheduler/host_manager.py class HostState
type APINovaExternalSchedulerRequestHost struct {
	Name   string `json:"name"`
	Status string `json:"status"`
}

// Request generated by the Nova scheduler when calling cortex.
// The request contains a spec of the VM to be scheduled, a list of hosts and
// their status, and a map of weights that were calculated by the Nova weigher
// pipeline. Some additional flags are also included.
type APINovaExternalSchedulerRequest struct {
	Spec APINovaExternalSchedulerRequestSpec `json:"spec"`
	// Whether the Nova scheduling request is a rebuild request.
	Rebuild bool                                  `json:"rebuild"`
	Hosts   []APINovaExternalSchedulerRequestHost `json:"hosts"`
	Weights map[string]float64                    `json:"weights"`
}

// Response generated by cortex for the Nova scheduler.
// Cortex returns an ordered list of hosts that the VM should be scheduled on.
type APINovaExternalSchedulerResponse struct {
	Hosts []string `json:"hosts"`
}

// Check if the scheduler can run based on the request data.
func canRunScheduler(requestData APINovaExternalSchedulerRequest) (ok bool, reason string) {
	if requestData.Rebuild {
		return false, "rebuild is not supported"
	}
	if requestData.Spec.NInstances > 1 {
		return false, "only one instance is supported"
	}
	// Check that all hosts have a weight.
	for _, host := range requestData.Hosts {
		if _, ok := requestData.Weights[host.Name]; !ok {
			return false, "missing weight for host"
		}
	}
	// Check that all weights are assigned to a host in the request.
	hostNames := make(map[string]bool)
	for _, host := range requestData.Hosts {
		hostNames[host.Name] = true
	}
	for host := range requestData.Weights {
		if _, ok := hostNames[host]; !ok {
			return false, "weight assigned to unknown host"
		}
	}
	return true, ""
}

// APINovaExternalSchedulerHandler handles the POST request from the Nova scheduler.
// The request contains a spec of the VM to be scheduled, a list of hosts and
// their status, and a map of weights that were calculated by the Nova weigher
// pipeline. Some additional flags are also included.
// The response contains an ordered list of hosts that the VM should be scheduled on.
func APINovaExternalSchedulerHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		logging.Log.Error("invalid request method", "method", r.Method)
		http.Error(w, "invalid request method", http.StatusMethodNotAllowed)
		return
	}
	var requestData APINovaExternalSchedulerRequest
	if err := json.NewDecoder(r.Body).Decode(&requestData); err != nil {
		logging.Log.Error("failed to decode request", "error", err)
		http.Error(w, "bad request", http.StatusBadRequest)
		return
	}
	logging.Log.Info(
		"handling POST request",
		"url", APINovaExternalSchedulerURL, "rebuild", requestData.Rebuild,
		"hosts", len(requestData.Hosts), "spec", requestData.Spec,
	)

	if ok, reason := canRunScheduler(requestData); !ok {
		logging.Log.Error("cannot run scheduler", "reason", reason)
		http.Error(w, reason, http.StatusBadRequest)
		return
	}

	// Create the pipeline context from the request data.
	state := pipelineState{}
	state.Spec.ProjectID = requestData.Spec.ProjectID
	for _, host := range requestData.Hosts {
		state.Hosts = append(state.Hosts, struct {
			Name   string
			Status string
		}{
			Name:   host.Name,
			Status: host.Status,
		})
	}
	state.Weights = requestData.Weights

	// Evaluate the pipeline and return the ordered list of hosts.
	hosts, err := evaluatePipeline(state)
	if err != nil {
		logging.Log.Error("failed to evaluate pipeline", "error", err)
		http.Error(w, "failed to evaluate pipeline", http.StatusInternalServerError)
		return
	}
	response := APINovaExternalSchedulerResponse{Hosts: hosts}
	w.Header().Set("Content-Type", "application/json")
	if err = json.NewEncoder(w).Encode(response); err != nil {
		logging.Log.Error("failed to encode response", "error", err)
		http.Error(w, "failed to encode response", http.StatusInternalServerError)
		return
	}
}
