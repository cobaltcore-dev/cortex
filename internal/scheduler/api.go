// Copyright 2025 SAP SE
// SPDX-License-Identifier: Apache-2.0

package scheduler

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"strconv"
	"time"

	"github.com/cobaltcore-dev/cortex/internal/conf"
	"github.com/cobaltcore-dev/cortex/internal/db"
	"github.com/cobaltcore-dev/cortex/internal/scheduler/plugins"
)

// Host object from the Nova scheduler pipeline.
// See: https://github.com/sapcc/nova/blob/stable/xena-m3/nova/scheduler/host_manager.py class HostState
type APINovaExternalSchedulerRequestHost struct {
	// Name of the Nova compute host, e.g. nova-compute-bb123.
	ComputeHost string `json:"host"`
	// Name of the hypervisor hostname, e.g. domain-c123.<uuid>
	HypervisorHostname string `json:"hypervisor_hostname"`
}

// Request generated by the Nova scheduler when calling cortex.
// The request contains a spec of the VM to be scheduled, a list of hosts and
// their status, and a map of weights that were calculated by the Nova weigher
// pipeline. Some additional flags are also included.
type APINovaExternalSchedulerRequest struct {
	Spec NovaObject[NovaSpec] `json:"spec"`

	// Whether the Nova scheduling request is a rebuild request.
	Rebuild bool `json:"rebuild"`
	// Whether the Nova scheduling request is a resize request.
	Resize bool `json:"resize"`
	// Whether the Nova scheduling request is a live migration.
	Live bool `json:"live"`
	// Whether the affected VM is a VMware VM.
	VMware bool `json:"vmware"`

	Hosts   []APINovaExternalSchedulerRequestHost `json:"hosts"`
	Weights map[string]float64                    `json:"weights"`
}

// Response generated by cortex for the Nova scheduler.
// Cortex returns an ordered list of hosts that the VM should be scheduled on.
type APINovaExternalSchedulerResponse struct {
	Hosts []string `json:"hosts"`
}

type ExternalSchedulingAPI interface {
	NovaExternalScheduler(w http.ResponseWriter, r *http.Request)
	GetNovaExternalSchedulerURL() string
}

type externalSchedulingAPI struct {
	Pipeline Pipeline
	config   conf.Config
	monitor  Monitor
}

func NewExternalSchedulingAPI(config conf.Config, db db.DB, m Monitor) ExternalSchedulingAPI {
	return &externalSchedulingAPI{
		Pipeline: NewPipeline(config, db, m),
		config:   config,
		monitor:  m,
	}
}

func (api *externalSchedulingAPI) GetNovaExternalSchedulerURL() string {
	return "/scheduler/nova/external"
}

// Check if the scheduler can run based on the request data.
// Note: messages returned here are user-facing and should not contain internal details.
func (api *externalSchedulingAPI) canRunScheduler(requestData APINovaExternalSchedulerRequest) (ok bool, reason string) {
	if requestData.Rebuild {
		return false, "rebuild is not supported yet"
	}
	if requestData.Spec.Data.NInstances > 1 {
		return false, "only one instance is supported so far"
	}
	if requestData.Live {
		return false, "live migration is not supported yet"
	}
	if !requestData.VMware {
		return false, "non-vmware VMs are not supported yet"
	}
	// Check that all hosts have a weight.
	for _, host := range requestData.Hosts {
		if _, ok := requestData.Weights[host.ComputeHost]; !ok {
			return false, "missing weight for host"
		}
	}
	// Check that all weights are assigned to a host in the request.
	computeHostNames := make(map[string]bool)
	for _, host := range requestData.Hosts {
		computeHostNames[host.ComputeHost] = true
	}
	for computeHost := range requestData.Weights {
		if _, ok := computeHostNames[computeHost]; !ok {
			return false, "weight assigned to unknown host"
		}
	}
	return true, ""
}

// APINovaExternalSchedulerHandler handles the POST request from the Nova scheduler.
// The request contains a spec of the VM to be scheduled, a list of hosts and
// their status, and a map of weights that were calculated by the Nova weigher
// pipeline. Some additional flags are also included.
// The response contains an ordered list of hosts that the VM should be scheduled on.
func (api *externalSchedulingAPI) NovaExternalScheduler(w http.ResponseWriter, r *http.Request) {
	// Monitor the time it takes to handle the request.
	// Also add the response code and potential error.
	startTime := time.Now()
	var respondWith = func(code int, err error, text string) {
		if api.monitor.apiRequestsTimer != nil {
			observer := api.monitor.apiRequestsTimer.WithLabelValues(
				r.Method,
				api.GetNovaExternalSchedulerURL(),
				strconv.Itoa(code),
				text, // Internal error messages should not face the monitor.
			)
			observer.Observe(time.Since(startTime).Seconds())
		}
		if err != nil {
			slog.Error("failed to handle request", "error", err)
			http.Error(w, text, code)
			return
		}
		// If there was no error, nothing else to do.
	}

	// Exit early if the request method is not POST.
	if r.Method != http.MethodPost {
		respondWith(
			http.StatusMethodNotAllowed,
			fmt.Errorf("invalid request method: %s", r.Method),
			"invalid request method",
		)
		return
	}

	// Ensure body is closed after reading.
	defer r.Body.Close()

	// If configured, log out the complete request body.
	if api.config != nil && api.config.GetSchedulerConfig().LogRequestBodies {
		body, err := io.ReadAll(r.Body)
		if err != nil {
			respondWith(
				http.StatusInternalServerError,
				fmt.Errorf("failed to read request body: %w", err),
				"failed to read request body",
			)
			return
		}
		slog.Info("request body", "body", string(body))
		r.Body = io.NopCloser(bytes.NewBuffer(body)) // Restore the body for further processing
	}

	var requestData APINovaExternalSchedulerRequest
	if err := json.NewDecoder(r.Body).Decode(&requestData); err != nil {
		respondWith(
			http.StatusBadRequest,
			fmt.Errorf("failed to decode request: %w", err),
			"failed to decode request",
		)
		return
	}
	slog.Info(
		"handling POST request",
		"url", api.GetNovaExternalSchedulerURL(), "rebuild", requestData.Rebuild,
		"hosts", len(requestData.Hosts), "spec", requestData.Spec,
	)

	if ok, reason := api.canRunScheduler(requestData); !ok {
		respondWith(
			http.StatusBadRequest,
			fmt.Errorf("cannot run scheduler: %s", reason),
			reason,
		)
		return
	}

	// Create the pipeline context from the request data.
	state := &plugins.State{}
	state.Spec.ProjectID = requestData.Spec.Data.ProjectID
	for _, host := range requestData.Hosts {
		state.Hosts = append(state.Hosts, plugins.StateHost(host))
	}
	state.Weights = requestData.Weights

	// Nova may give us very large (positive/negative) weights such as
	// -99,000 or 99,000. We want to respect these values, but still adjust them
	// to a meaningful value. If Nova really doesn't want us to run on a host, it
	// should run a filter instead of setting a weight.
	state.ScaleNovaValues() // Uses an activation function to scale the weights.

	// Evaluate the pipeline and return the ordered list of hosts.
	hosts, err := api.Pipeline.Run(state)
	if err != nil {
		respondWith(
			http.StatusInternalServerError,
			fmt.Errorf("failed to evaluate pipeline: %w", err),
			"failed to evaluate pipeline",
		)
		return
	}
	response := APINovaExternalSchedulerResponse{Hosts: hosts}
	w.Header().Set("Content-Type", "application/json")
	if err = json.NewEncoder(w).Encode(response); err != nil {
		respondWith(
			http.StatusInternalServerError,
			fmt.Errorf("failed to encode response: %w", err),
			"failed to encode response",
		)
		return
	}
	respondWith(http.StatusOK, nil, "Success")
}
