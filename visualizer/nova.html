<!-- Copyright 2025 SAP SE -->
<!-- SPDX-License-Identifier: Apache-2.0 -->

<!DOCTYPE html>
<html>
  <head>
    <title>Cortex Nova Visualizer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <!-- Shared CSS styles -->
    <link rel="stylesheet" href="shared.css">
    <style>
      td.chart div.barsbefore p,
      td.chart div.barsafter p,
      td.chart div.backdrop p,
      td.chart div.stats p {
        width: 30%; /* 3 columns */
      }
    </style>

    <!-- MQTT library from vendor folder. -->
    <script src="mqtt.min.js"></script>

  <section id="app">
    <!-- Display a loading indicator as long as no data has arrived. -->
    <div class="progress"></div>
    <div class="progress-text">Waiting for mqtt data to arrive...</div>
  </section>

  <section class="mqtt-url-input">
    <input type="text" id="mqtt-url" placeholder="Enter MQTT URL" value="ws://localhost:8001/ws" />
    <button onclick="reconnect()">Reconnect MQTT</button>
    <button onclick="disconnect()">Disconnect MQTT</button>
  </section>

  <script>
    let state = {
      pipeline: {},
      utilizations: {},
    }

    let client
    async function disconnect() {
      if (client) client.end()
    }
    async function reconnect() {
      const url = document.getElementById('mqtt-url').value
      if (!url) return
      if (client) client.end()
      client = mqtt.connect(url, {
        username: 'cortex',
        password: 'secret',
        protocolVersion: 4,
      })
      client.on('message', (topic, message) => {
        if (topic === 'cortex/scheduler/nova/pipeline/finished') {
          state.pipeline = JSON.parse(message.toString())
          console.log('Pipeline data received:', state.pipeline)
        }
        if (topic === 'cortex/extraction/host_utilization_extractor') {
          state.utilizations = JSON.parse(message.toString())
          console.log('Utilization data received:', state.utilizations)
        }
        redraw()
      })
      client.on('connect', () => {
        console.log('Connected to MQTT broker.')
        client.subscribe('cortex/scheduler/nova/pipeline/finished')
        client.subscribe('cortex/extraction/host_utilization_extractor')
      })
    }
    reconnect()

    async function redraw () {
      if (Object.keys(state.pipeline).length === 0) return

      const greyout = 'filter: grayscale(50%); opacity: 0.25'

      const spec = state.pipeline.request.spec["nova_object.data"]
      const flavor = spec.flavor["nova_object.data"]

      // Get the utilization by service host.
      utilizations = {}
      if (Array.isArray(state.utilizations) && state.utilizations.length > 0) {
        for (const u of state.utilizations) {
          utilizations[u.computeHost] = u
        }
      }
      const hostnames = Object.keys(utilizations).sort((a, b) => {
        if (state.pipeline.in[a] === undefined) return 1
        if (state.pipeline.in[b] === undefined) return -1
        // If both values are equal (e.g. both undefined) compare by the name.
        if (state.pipeline.out[a] === state.pipeline.out[b]) return a.localeCompare(b)
        if (state.pipeline.out[a] === undefined) return 1
        if (state.pipeline.out[b] === undefined) return -1
        return state.pipeline.out[b] - state.pipeline.out[a]
      })

      // Also include the nova input weights, scaled weights, and output weights.
      steps = {
        ...state.pipeline.steps,
        'nova input': state.pipeline.request.weights,
        'scaled weights': state.pipeline.in,
        'output weights': state.pipeline.out,
      }
      order = ['nova input', 'scaled weights', ...state.pipeline.order, 'output weights']
      highlights = ['nova input', 'output weights']

      let table = '<table>'
      // Add weights to the table.
      for (const stepkey of order) {
        // Add a header with the name of the step.
        table += `
          <tr>
            <th class="stepkey" colspan="${hostnames.length + 1}">${stepkey}</th>
          </tr>
        `

        const weights = steps[stepkey]
        if (weights === undefined) {
          console.warn(`No weights found for step "${stepkey}"`)
          continue
        }
        table += `<tr class="${highlights.includes(stepkey) ? 'highlight' : ''}">`
        for (const host of hostnames) {
          if (weights[host] === undefined) {
            table += '<td class="weight"></td>'
            continue
          }
          const weight = weights[host]
          const norm = Math.min(1, Math.max(0, (weight + 1) / 2))
          let bg = `rgba(255, 71, 87, ${1 - (norm * 2)})`
          if (weight >= 0) {
            bg = `rgba(46, 213, 115, ${(norm * 2) - 1})`
          }
          let color = norm > 0.75 || norm < 0.25 ? 'white' : 'black'
          table += `
            <td class="weight">
              <div
                style="background: ${bg}; color: ${color}"
              >${weight.toFixed(2)}</div>
            </td>
          `
        }
        table += '</tr>'
      }
      // Add hosts to the table.
      table += '<tr>'
      for (const host of hostnames) {
        const hasWeight = state.pipeline.out[host] !== undefined
        table += `
          <th class="hostname" style="${hasWeight ? '' : greyout}">
            <div>${host}</div>
          </th>
        `
      }
      table += '</tr>'

      // Add utilization statistics to the table.
      table += '<tr>'
      let maxVCPUs = 0
      let maxMemMB = 0
      let maxDiskGB = 0
      for (const host of hostnames) {
        const utilization = utilizations[host]
        if (utilization) {
          maxVCPUs = Math.max(maxVCPUs, utilization.totalVCPUsAllocatable)
          maxMemMB = Math.max(maxMemMB, utilization.totalMemoryAllocatableMB)
          maxDiskGB = Math.max(maxDiskGB, utilization.totalDiskAllocatableGB)
        }
      }
      for (const host of hostnames) {
        const hasWeight = state.pipeline.out[host] !== undefined
        const utilization = utilizations[host]

        const cpusUsed = utilization.vcpusUtilizedPct / 100
        const memUsed = utilization.ramUtilizedPct / 100
        const diskUsed = utilization.diskUtilizedPct / 100
        const cpusUsedAfter = (cpusUsed * utilization.totalVCPUsAllocatable + flavor.vcpus) / utilization.totalVCPUsAllocatable
        const memUsedAfter = (memUsed * utilization.totalMemoryAllocatableMB + flavor.memory_mb) / utilization.totalMemoryAllocatableMB
        const diskUsedAfter = (diskUsed * utilization.totalDiskAllocatableGB + flavor.disk) / utilization.totalDiskAllocatableGB
        const cpusUsedScaled = cpusUsed * utilization.totalVCPUsAllocatable / maxVCPUs
        const memUsedScaled = memUsed * utilization.totalMemoryAllocatableMB / maxMemMB
        const diskUsedScaled = diskUsed * utilization.totalDiskAllocatableGB / maxDiskGB
        const cpusUsedAfterScaled = cpusUsedAfter * utilization.totalVCPUsAllocatable / maxVCPUs
        const memUsedAfterScaled = memUsedAfter * utilization.totalMemoryAllocatableMB / maxMemMB
        const diskUsedAfterScaled = diskUsedAfter * utilization.totalDiskAllocatableGB
        const totalVCPUsAllocatableScaled = utilization.totalVCPUsAllocatable / maxVCPUs
        const totalMemoryAllocatableMBScaled = utilization.totalMemoryAllocatableMB / maxMemMB
        const totalDiskAllocatableGBScaled = utilization.totalDiskAllocatableGB / maxDiskGB

        table += `
          <td class="chart" style="${hasWeight ? '' : greyout}">
              <div class="backdrop">
                <p class="cpu" style="height: ${Math.min(100, totalVCPUsAllocatableScaled * 100)}%"></p>
                <p class="mem" style="height: ${Math.min(100, totalMemoryAllocatableMBScaled * 100)}%"></p>
                <p class="disk" style="height: ${Math.min(100, totalDiskAllocatableGBScaled * 100)}%"></p>
              </div>
              <div class="barsafter">
                <p class="cpu" style="height: ${Math.min(100, cpusUsedAfterScaled * 100)}%"></p>
                <p class="mem" style="height: ${Math.min(100, memUsedAfterScaled * 100)}%"></p>
                <p class="disk" style="height: ${Math.min(100, diskUsedAfterScaled * 100)}%"></p>
              </div>
              <div class="barsbefore">
                <p class="cpu" style="height: ${Math.min(100, cpusUsedScaled * 100)}%"></p>
                <p class="mem" style="height: ${Math.min(100, memUsedScaled * 100)}%"></p>
                <p class="disk" style="height: ${Math.min(100, diskUsedScaled * 100)}%"></p>
              </div>
              <div class="stats">
                <p>${Math.round(cpusUsed * utilization.totalVCPUsAllocatable)} / ${utilization.totalVCPUsAllocatable} vCPUs</p>
                <p>${Math.round(memUsed * utilization.totalMemoryAllocatableMB / 1000)} / ${Math.round(utilization.totalMemoryAllocatableMB / 1000)} GB MEM</p>
                <p>${Math.round(diskUsed * utilization.totalDiskAllocatableGB)} / ${utilization.totalDiskAllocatableGB} GB DISK</p>
              </div>
            </div>
          </td>
        `
      }
      table += '</tr>'

      const nav = `
        <nav>
          <div class="element"><p class="highlight">Cortex Nova</p>Scheduled VM:</div>
          <div class="element"><p class="highlight">VMware</p>${state.pipeline.request.vmware}</div>
          <div class="element"><p class="highlight">Live Migration</p>${state.pipeline.request.live}</div>
          <div class="element"><p class="highlight">Resize</p>${state.pipeline.request.live}</div>
          <div class="element"><p class="highlight">Availability Zone</p>${spec.availability_zone}</div>
          <div class="element"><p class="highlight">Flavor</p>${flavor.name} (MB: ${flavor.memory_mb}, vCPUs: ${flavor.vcpus})</div>
        </nav>
      `

      document.querySelector('#app').innerHTML = `
        <main>
          ${table}
          ${nav}
        </main>
      `
    }
  </script>
</html>
