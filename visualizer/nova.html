<!DOCTYPE html>
<html>

<head>
  <title>Cortex Nova Visualizer</title>
  <meta charset="utf-8">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link rel="stylesheet" href="shared.css">
  <style>
    td.chart div.barsbefore p,
    td.chart div.barsafter p,
    td.chart div.backdrop p,
    td.chart div.stats p {
      width: 30%;
    }

    body {
      margin: 0;
      padding: 0;
      height: 100vh;
      overflow: hidden;
    }

    .app-container {
      display: grid;
      grid-template-columns: var(--sidebar-width, 300px) 1fr;
      grid-template-rows: 60px 1fr;
      grid-template-areas:
        "header header"
        "sidebar main";
      height: 100vh;
      transition: grid-template-columns 0.3s ease;
    }

    .app-container.sidebar-collapsed {
      --sidebar-width: 0px;
      grid-template-columns: 0px 1fr;
    }

    .header {
      grid-area: header;
      background-color: #2c3e50;
      color: white;
      display: flex;
      align-items: center;
      padding: 0 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      z-index: 100;
    }

    .sidebar-toggle {
      background: none;
      border: none;
      color: white;
      font-size: 18px;
      cursor: pointer;
      padding: 10px;
      margin-right: 15px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }

    .sidebar-toggle:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .header-title {
      font-size: 20px;
      font-weight: 600;
    }

    .sidebar {
      grid-area: sidebar;
      background-color: #f8f9fa;
      border-right: 1px solid #dee2e6;
      overflow-y: auto;
      overflow-x: hidden;
      transition: width 0.3s ease;
      width: var(--sidebar-width, 300px);
      box-sizing: border-box;
    }

    .sidebar-collapsed .sidebar {
      width: 0;
      border-right: none;
    }

    .main {
      grid-area: main;
      padding: 20px;
      overflow: auto;
      background-color: white;
    }

    .sidebar-content {
      padding: 15px;
    }

    .sidebar-section {
      margin-bottom: 25px;
    }

    .sidebar-section h3 {
      margin: 0 0 15px 0;
      color: #495057;
      font-size: 16px;
      font-weight: 600;
      border-bottom: 2px solid #e9ecef;
      padding-bottom: 8px;
    }

    .sidebar-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .sidebar-list li {
      padding: 8px 12px;
      border-radius: 6px;
      margin-bottom: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      font-size: 14px;
    }

    .sidebar-list li:hover {
      background-color: #e9ecef;
    }

    .sidebar-list li.active {
      background-color: #007bff;
      color: white;
    }

    .filter-input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ced4da;
      border-radius: 4px;
      font-size: 14px;
      margin-bottom: 15px;
      box-sizing: border-box;
    }

    .filter-input:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, .25);
    }
  </style>
</head>

<body>
  <div class="app-container" id="appContainer">
    <div class="header">
      <button class="sidebar-toggle" onclick="toggleSidebar()">â˜°</button>
      <div class="header-title">Cortex Nova Visualizer</div>
    </div>

    <div class="sidebar">
      <div class="sidebar-content">
        <div class="sidebar-section">
          <input type="text" class="filter-input" placeholder="Search VM ID..." id="vmIdFilter">
          <button onclick="applyFilters()"
            style="width: 100%; padding: 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Search</button>
        </div>

        <div class="sidebar-section">
          <h3>Recent Decisions</h3>
          <ul class="sidebar-list" id="decisionsList">
            <!-- Will be filled dynamically -->
          </ul>
        </div>
      </div>
    </div>

    <div class="main">
      <section id="app">
        <div class="progress"></div>
        <div class="progress-text">Loading...</div>
        <!-- Main content will be rendered here -->
      </section>
    </div>
  </div>

  <script>
    const state = {
      schedulingDecisions: [],
      selectedDecisions: null,
      sidebarCollapsed: false
    }

    // Sidebar toggle functionality
    function toggleSidebar() {
      state.sidebarCollapsed = !state.sidebarCollapsed
      const container = document.getElementById('appContainer')
      container.classList.toggle('sidebar-collapsed', state.sidebarCollapsed)

      // Save state to localStorage
      localStorage.setItem('sidebarCollapsed', state.sidebarCollapsed)
    }

    // Load sidebar state from localStorage
    function loadSidebarState() {
      const saved = localStorage.getItem('sidebarCollapsed')
      if (saved === 'true') {
        state.sidebarCollapsed = true
        document.getElementById('appContainer').classList.add('sidebar-collapsed')
      }
    }

    // Apply filters from sidebar
    function applyFilters() {
      const vmId = document.getElementById('vmIdFilter').value.trim()

      if (vmId) {
        navigateToDecision(vmId)
      }
    }

    // Navigate to specific decision
    function navigateToDecision(vmId) {
      const newUrl = `${window.location.pathname}?vm_id=${vmId}`
      window.history.pushState({ vmId }, '', newUrl)
      updateCurrentDecision()
    }

    // Update sidebar with decisions list
    function updateSidebar() {
      const decisionsList = document.getElementById('decisionsList')

      // Update decisions list
      decisionsList.innerHTML = ''
      // Only display the first 100 decisions for performance
      state.schedulingDecisions.slice(0, 100).forEach(decision => {
        const li = document.createElement('li')
        li.textContent = `${decision.metadata.name}`
        li.onclick = () => {
          document.getElementById('vmIdFilter').value = ""
          navigateToDecision(decision.metadata.name)
        }

        if (state.selectedDecisions &&
          state.selectedDecisions.metadata.name === decision.metadata.name) {
          li.classList.add('active')
        }

        decisionsList.appendChild(li)
      });
    }

    // Update the current displayed decision based on the vm_id URL parameter.
    function updateCurrentDecision() {
      const urlParams = new URLSearchParams(window.location.search);
      const vmId = urlParams.get('vm_id')

      if (!vmId) {
        state.selectedDecisions = null
        updateSidebar()
        return
      }

      listSchedulingDecisions(vmId)
        .then(decision => {
          if (!decision) {
            alert(`No scheduling decision found for vm_id ${vmId}`)
            return
          }
          state.selectedDecisions = decision
          updateSidebar()
          redraw()
        })
        .catch(error => {
          alert('Error loading scheduling decision: ' + error)
          state.selectedDecisions = null
          updateSidebar()
        })
    }

    // List scheduling decisions, optionally filtered by vmId.
    async function listSchedulingDecisions(vmId) {
      let url = 'http://localhost:8014/scheduler/nova/scheduling-decisions'

      if (vmId) {
        url += `?vm_id=${vmId}`
      }
      const response = await fetch(url)
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      return await response.json()
    }

    // Update the URL to reflect the currently selected decision.
    window.addEventListener('popstate', updateCurrentDecision)

    // Draw individual decisions
    function drawDecision(app, spec, status, vmId) {
      const detailsToDisplay = [
        {
          "name": "Event Type",
          "value": spec.eventType
        },
        {
          "name": "VM ID",
          "value": vmId
        },
        {
          "name": "Request ID",
          "value": spec.id
        },
        {
          "name": "Availability Zone",
          "value": spec.availabilityZone
        },
        {
          "name": "Flavor",
          "value": `${spec.flavor.name} (MB: ${spec.flavor.requests.memory}, vCPUs: ${spec.flavor.requests.cpu})`
        },
        {
          "name": "Decision",
          "value": `${status.description}`
        }
      ]

      const details = document.createElement('nav')
      for (const detail of detailsToDisplay) {
        const detailDiv = document.createElement('div')
        detailDiv.classList.add('element')
        detailDiv.innerHTML = `<p class="highlight">${detail.name}</p>${detail.value}`
        details.appendChild(detailDiv)
      }

      app.appendChild(details)


      const decisionSteps = {}
      const decisionOrder = []

      for (const step of spec.pipeline.outputs ?? []) {
        decisionSteps[step.step] = step.activations
        decisionOrder.push(step.step)
      }

      const steps = {
        ...decisionSteps,
        'scaled nova weights': spec.input,
        'output weights': status.finalScores,
      }
      const order = ['scaled nova weights', ...decisionOrder, 'output weights']
      const highlights = ['scaled nova weights', 'output weights']

      const hostnames = Object.keys(status.finalScores || {}).sort((a, b) => {
        const scoreA = status.finalScores[a]
        const scoreB = status.finalScores[b]

        // Handle undefined values - put them at the end
        if (scoreA === undefined && scoreB === undefined) return a.localeCompare(b)
        if (scoreA === undefined) return 1
        if (scoreB === undefined) return -1

        // Sort by score (descending), then by name
        return scoreB - scoreA || a.localeCompare(b)
      })

      const table = document.createElement('table')
      app.appendChild(table)

      let innerTable = ""

      for (const stepkey of order) {
        innerTable += `
          <tr>
            <th class="stepkey" colspan="${hostnames.length + 1}">${stepkey}</th>
          </tr>
        `
        const weights = steps[stepkey]
        if (weights === undefined) {
          console.warn(`No weights found for step "${stepkey}"`)
          continue
        }
        const className = highlights.includes(stepkey) ? 'highlight' : ''
        innerTable += `<tr class="${className}">`
        for (const host of hostnames) {
          if (weights[host] === undefined) {
            innerTable += '<td class="weight"></td>'
            continue
          }
          const weight = weights[host]
          const norm = Math.min(1, Math.max(0, (weight + 1) / 2))
          let bg = `rgba(255, 71, 87, ${1 - (norm * 2)})`
          if (weight >= 0) {
            bg = `rgba(46, 213, 115, ${(norm * 2) - 1})`
          }
          let color = norm > 0.75 || norm < 0.25 ? 'white' : 'black'
          innerTable += `
            <td class="weight">
              <div
                style="background: ${bg}; color: ${color};"
              >${weight.toFixed(2)}</div>
            </td>
          `
        }
        innerTable += '</tr>'
      }

      const greyout = 'filter: grayscale(50%) opacity: 0.25'
      // Add hosts to the table.
      innerTable += '<tr>'
      for (const host of hostnames) {
        const hasWeight = status.finalScores[host] !== undefined
        innerTable += `
          <th class="hostname" style="${hasWeight ? '' : greyout}">
            <div>${host}</div>
          </th>
        `
      }

      table.innerHTML = innerTable
      app.appendChild(table)
    }


    // Redraw main content based on selected decision
    function redraw() {
      const app = document.querySelector('#app')
      app.innerHTML = ''

      if (!state.selectedDecisions) {
        app.innerHTML = `
        <div>
          <p>Select a scheduling decision from the sidebar</p>
        </div>
      `
        return
      }

      const vmId = state.selectedDecisions.metadata.name

      for (const spec of state.selectedDecisions.spec.decisions) {
        const status = state.selectedDecisions.status.results.find(d => d.id === spec.id) || {}
        drawDecision(app, spec, status, vmId)
      }
    }

    // Initialize app
    function initApp() {
      loadSidebarState()

      listSchedulingDecisions()
        .then(data => {
          state.schedulingDecisions = data.items || []
          updateSidebar()
          redraw()
        })
        .then(updateCurrentDecision)
        .catch(error => {
          alert('Error loading scheduling decisions: ' + error)
        })
    }

    // Start the app
    initApp()
  </script>

</body>

</html>